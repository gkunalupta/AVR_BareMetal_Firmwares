

void Timer_delay_check_oscil(void)
{   
	TCCR1B|=(1<<CS12)|(1<<CS10);               // clk/1024
    TCCR0B|= (1<<CS01);                //clk/8  --- 5*10^-7
    SET_BIT(DDRB,PB4);               // make pin as output
    CLEAR_BIT(PORTB,PB4);            // make pin low ... this is the start signal for 18ms
	TCNT1=0;
    while(TCNT1<=281);       //takes 290 ticks to generate 18ms;
    SET_BIT(PORTB,PB4);              //MCU pull  pin to high 
    TCNT1=0;
    while(TCNT1<=281); 

}

	
#define delay7 false
 void dht11_init()
{
	
	
		TCCR1B=(1<<CS12)|(1<<CS10);        // clk/1024   --> Timer Clock time period : 6.4*10^-5 secs
		TCNT1=0;                           // As start signal is 18ms , so it will be requiring TIMER1
		
		TCCR0B|= (1<<CS01);                //clk/8  ---> Timer Clock time period :5*10^-7
		TCNT0=0;                           //Apart from Start signal all signals can be monitored and generated by TIMER0 
		
		SET_BIT(DDRH,PH4);                 //Set pin as output so that start signal can be send      
		CLEAR_BIT(PORTH,PH4);              // Low pulse is send as Start signal
		
		TCNT1=0;
		while(TCNT1<=281);                 // Start signal of 18ms delay : 282* ( 6.4*10^-5 secs)
		
		//return 22;
		SET_BIT(PORTH,PH4);                //High pulse is set to receive response from sensor
		TCNT0=0;
		while(TCNT0<=80);                   //wait for 40us : 80 * (5*10^-7) befor receiving response
		//printString0("\nP\n");
		CLEAR_BIT(DDRH,PH4);           // Set pin as input as now sensor will send the response signal
		//return 30;
}
//Now you have to check pin status of DHT11..

int dht11_find_response()
{
	    //While sensor pull the pin low for 80us
		if(!(IS_SET(PINH,PH4)))         //first response signal is low
		 { TCNT0=0;
		while(TCNT0<=170); }           // While sensor pull the pin low for 85us : 170 * ((5*10^-7)
		else
		return 1;
	    if(IS_SET(PINH,PH4))           //Second response signal is high
		{TCNT0=0;
		while(TCNT0<=170); }          //  While sensor pull the pin HIGH for 85us : 170 * ((5*10^-7)
		else
		return 2;
	
}

/* 
now sensor sends data and Pin is always in Input state for this phase
now data signal is received in the pack of 5 : each pack having 8 bits
each data bit is of HIGH pulse : 70us is read as 1
                                 26-28us is read as 0 bit
Each data Bit is followed by a Low Pulse of 54us 

The output given out by the data pin will be in the order of
8bit humidity integer data + 8bit the Humidity decimal data 
+8 bit temperature integer data + 8bit fractional temperature data +
8 bit parity bit

Parity bit is sum of 
*/
uint8_t data [5];
int dht11_receivedht()
//int dht11_receivedht(uint8_t *x)
{	
 uint8_t  check;
 volatile uint8_t cnt = 0;
	
	for (int z = 0; z < 5; ++z)
	{
        for(int j = 7; j >= 0; --j)
        {
           
             /* First there is always a 50µs low period */
			 TCNT0=0;
			 while(!IS_SET(PINH,PH4))
			  {
				if(TCNT0 >= 120)    //Wait for 50us low pulse
				//to see if low signal is detected or not uncomment the below 4 lines and remove semicolan from if
				{ 
					decimel0(TCNT0);
					return 12;
					//break;
				}
			}
			 /* Then the data signal is sent. 26 to 28µs (ideally)
             indicate a low bit, and around 70µs a high bit */
			 TCNT0=0;
            while(IS_SET(PINH,PH4))        // if Signal is HIGH
            { 
				
				if (TCNT0 <= 160)              // data signal is high for max 71us (as for 0 it is 26-28us and for 1 it is 70us)
				cnt = TCNT0;                   // So for 160 , 71us is generated to waiting for maximum time.
			    else
			  {
				   decimel0(TCNT0);            //if data signal is high for more then 70us then their is some error       
 				   printString0("\n");
				   return 1; 
			  }
		     }
	  
		
            /* Store the value now so that the whole checking doesn't
             move the TCNT0 forward by too much to make the data look
             bad */
            
            if ((cnt >= 40) & (cnt <= 70))          //20us to 35 us
            CLEAR_BIT(data[z],j); //decimel0(cnt);printString0("\n");}
			
            else if ((cnt >= 120) & (cnt <= 160))     // 60us to 80us
            SET_BIT(data[z],j);//decimel0(cnt); printString0("\n");}
			
            else
			{printString0("error 2\n"); decimel0(cnt);       //if data signal is high for more then 70us then their is some error
			 return 2;}
		}
	}
	
	check = (data[0] + data[1] + data[2] + data[3]) & 0xFF;
	if (check != data[4]) return 3;
	/*
	for(int w = 0; w <= 4; w++)
	{ 
	  x[w] = data[w]; 
	}
	*/
	return 4;
}
void dht11()
{
			dht11_init();
			dht11_find_response();
			dht11_receivedht();
}
uint8_t dht11_hum()
{
	return (data[0] + (0.1*data[1]));
	
}

float dht11_temp()
{
	return (data[2] + (0.1*data[3]));
}




#define delay10 true
void dht11_init10()
{
	if(delay10 == true)
	{
		
	TCCR0B|= (1<<CS01);                //clk/8  --- 5*10^-7
	TCCR1B|=(1<<CS12)|(1<<CS10);               // clk/1024
	SET_BIT(DDRB,PB4);
	CLEAR_BIT(PORTB,PB4);
	_delay_ms(20);              //max-30
	SET_BIT(PORTB,PB4);
	_delay_us(40);
	CLEAR_BIT(DDRB,PB4);
	}
	else
	{
		TCCR1B|=(1<<CS12)|(1<<CS10);
		TCNT1=0;               // clk/1024
		TCCR0B|= (1<<CS01);                //clk/8  --- 5*10^-7
		TCNT0=0;
		SET_BIT(DDRB,PB4);
		printString0("Starting dht11\n");
		CLEAR_BIT(PORTB,PB4);
		{TCNT1=0;
		while(TCNT1<=281);}
		SET_BIT(PORTB,PB4);
		{TCNT0=0;
		while(TCNT0<=80);}
		printString0("\nP\n");
		CLEAR_BIT(DDRB,PB4);
	}
}
//Now you have to check pin status of DHT11..

int dht11_find_response10()
{
	if(delay10 == true)
	{
	//While sensor pull the pin low for 80us
	if(!(IS_SET(PINB,PB4)))         //first response signal is low
	_delay_us(82);                  //While sensor pull the pin low for 80us(max-140)
	else
	return 1;
	if(IS_SET(PINB,PB4))           //Second response signal is high
	_delay_us(85);               //While sensor pull the pin HIGH for 80us(max-140)
	else
	return 2;
	}
	else
	{
		         //While sensor pull the pin low for 80us
		         if(!(IS_SET(PINB,PB4)))         //first response signal is low
		         { TCNT0=0;
		         while(TCNT0<=170); }   //_delay_us(85)   While sensor pull the pin low for 80us(max-140)
		         else
		         return 1;
		         if(IS_SET(PINB,PB4))           //Second response signal is high
		         {TCNT0=0;
		         while(TCNT0<=170); }          // _delay_us(85)   While sensor pull the pin HIGH for 80us(max-140
		         else
		         return 2;
	}
}

int dht11_receivedht10(uint8_t* arr)
{	
	uint8_t data [5];
 uint8_t  check;
	
	for (int z = 0; z < 5; ++z)
	{
        for(int j = 7; j >= 0; --j)
        {
           
          
            /* First there is always a 50µs low period */
			TCNT0=0;
			while(!IS_SET(PINB,PB4))
			{
				
				if(TCNT0 >= 120)
				//to see if low signal is detected or not uncomment the nbelow 4 lines and remove semicolan from if
				{ 
					decimel0(TCNT0);
					return 12;
					//break;
				}
				
				

			}
		
			
            
            TCNT0 = 0;
            
            /* Then the data signal is sent. 26 to 28µs (ideally)
             indicate a low bit, and around 70µs a high bit */
            while(IS_SET(PINB,PB4))
            { 
				if (TCNT0 >= 160 )              // data signal is high for max 71us (as for 0 it is 26-28us and for 1 it is 70us)
				{decimel0(TCNT0);
					printString0("\n");
				return 1; }
		     }
            
            /* Store the value now so that the whole checking doesn't
             move the TCNT0 forward by too much to make the data look
             bad */
            //cnt = TCNT0;
            
            if ((TCNT0 >= 40) & (TCNT0 <= 70))          //20us to 35 us
            { CLEAR_BIT(data[z],j); //decimel0(TCNT0);printString0("\n");
			}
            
            else if ((TCNT0 >= 120) & (TCNT0 <= 160))     // 60us to 80us
            { SET_BIT(data[z],j); //printString0("\n");decimel0(TCNT0); printString0("\n");
			}
           
            else
			{printString0("error 2\n"); decimel0(TCNT0); return 2;}
        }
		TCNT0=0;
	}   
	check = (data[0] + data[1] + data[2] + data[3]) & 0xFF;
	
	if (check != data[4]) return 3;
	//bit0(data[2]);
	for(int w = 0; w < 4; ++w)
	{ arr[w] = data[w]; }
	
	return 4;
}













/*

void dht11_init()
{   
	TCCR1B|=(1<<CS12)|(1<<CS10);
	TCNT1=0;               // clk/1024
	TCCR0B|= (1<<CS01);                //clk/8  --- 5*10^-7
	TCNT0=0;
	SET_BIT(DDRH,PH4);
	printString0("Starting dht11\n");
	CLEAR_BIT(PORTH,PH4);
	{TCNT1=0;
	while(TCNT1<=281);}
	SET_BIT(PORTH,PH4);
	{TCNT0=0;
	while(TCNT0<=80);}
	CLEAR_BIT(DDRH,PH4);
}
//Now you have to check pin status of DHT11..

int dht11_find_response()
{
             //While sensor pull the pin low for 80us
	if(!(IS_SET(PINH,PH4)))         //first response signal is low
	{ TCNT0=0;
	 while(TCNT0<=170); }   //_delay_us(85)   While sensor pull the pin low for 80us(max-140)
	else 
	return 1;
	if(IS_SET(PINH,PH4))           //Second response signal is high
	{TCNT0=0;
	 while(TCNT0<=170); }          // _delay_us(85)   While sensor pull the pin HIGH for 80us(max-140
    else
	return 2;
}*/